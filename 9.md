# So where were we?
## oh, remember how I said you dont have to write separate proofs for every function

- imagine implementing zipWith *properly* for 'List A', you'd have to prove that your function only takes in lists of the same length and returns back a list of the same length

```haskell
zipWith :
     {A B C : Type}
  -> (A -> B -> C)
  -> (as : List A) -> (bs : List B)
  -> ((len as) = (len bs))
  -> List C
zipWith as bs proof := /* duniya bhar ki jhanjhat */

zipWithReturnsBackAListOfTheSameLengthAsThatOfTheFirstInputList :
     {A B C : Type} (f : A -> B -> C)
  -> (as : List A) -> (bs : List B)
  -> (prf : (len as) = (len bs))
  -> Î£ (cs : List C), ((len cs) = (len as))
zipWithReturnsBackAListOfTheSameLengthAsThatOfTheInputList f as bs prf :=
  /* maaf karde bhai galti go gai */
```

*yuck*

- types likhne me hi phat gai
- lets try to do this with Vect instead of List

```haskell
zipWith :
     {A B C : Type} -> (A -> B -> C)
  -> {n : Nat} -> Vect A n -> Vect B n -> Vect C n
zipWith _ nil nil             := nil
zipWith f (a :: as) (b :: bs) := (f a b) :: (zipWith f as bs)
```

- and thats it.
- yeah
- in the lists one, I didnt even write the programs, only the types, while in the vect one, I wrote everything, and both the proofs are contained in this one
- The point I am trying to make is, if you encode information about your values in types, then you will naturally write proof carrying code without any wailing or crying. You can almost always easily switch between different types which encode different properties, write the relevant program in that type and then switch back.