# So for real now, what does this gain us

well, consider the following function:
```haskell
equal : Nat -> Nat -> Type
equal zero zero       := Top
equal zero (suc m)    := Bot
equal (suc n) zero    := Bot
equal (suc n) (suc m) := (equal n m)
```

and
```haskell
huh : equal (1 + 1) (2)
huh := triv

huuuuuhhh : equal (0) (1)
huuuuuhhh := ????????????????????????????????????????????????????????????????
```

==we just proved that 1 + 1 equals 2, we also tried proving that 0 equals 1 and failed at it==

also consider:
```haskell
_>=_ : Nat -> Nat -> Type
zero >= zero       := Top
zero >= (suc m)    := Bot
(suc n) >= zero    := Top
(suc n) >= (suc m) := (n >= m)

foo : (n : Nat) -> (n >= 1) -> String
foo (suc n) proof := "wut???"

bar : String
bar := foo 2 triv

baz : String
baz := foo 0 (???)
```

==foo can only be called if its input is greater than 0
the fact that every time this function is called its input is greater than 0 is ensured at compile time, no runtime checks are performed==