# But what does this gain us

## well, a lot

## but first, a detour

let 'Top' and 'Bot' be two types such that the only value of type 'Top' is 'triv' and there is no value of type 'Bot'

in rust this would look something like this:
```rust
enum Top {
  triv,
}

enum Bot {}
```

in our hypothetical language this looks like this:
```haskell
data Top : Type where
  triv : Top

data Bot : Type where
```

## yet another detour (bear with me pls)
### Inductive Types
- they are kind of like GADTs found in OCaml and Haskell (for those who know them)
- For those who dont, they are basically much more powerful enums which allow recursive definitions

- here is the type 'Bool' of Booleans:
```haskell
data Bool : Type where
  false : Bool
  true  : Bool
```

- here is the type 'Nat' of Natural numbers
```haskell
data Nat : Type where
  zero : Nat
  suc  : Nat -> Nat
```

in hypothetical rust syntax it would look something like this:
```rust
enum Nat {
  zero,
  suc(Nat),
}
```

this basically means that zero is a value of type Nat, and that 'suc' is a function that takes in a Nat and returns a new Nat

the defintions of Inductive Types specify how to pattern match on that type, so to pattern match on a Nat, you would need to specify what to do when you have a 'zero' and what to do when you have a 'suc n', where n is an unknown Nat