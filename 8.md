# Yet *yet* another detour
## Inductive Types and Families (somewhat properly this time)

- \<insert two hour long rant about inductive datatypes>

- key point:
- values are freely generated

- inductive types can have these things called parameters and indices
- first, parameters
- parameters are basically like rust's generics on structs and enums
```rust
enum Option_i32 {
  None,
  Some(i32),
}

enum Option_String {
  None,
  Some(String),
}
```

- imagine defining a separate option type for every type you may want to wrap in a option
- for this, rust has generics
```rust
enum Option<A> {
  None,
  Some(A),
}
```

```haskell
data Option (A : Type) : Type where
  None : Option A
  Some : A -> Option A
```

- it is worth mentioning than in rust, Option is this wierd object whose type we don't know and the identifier 'Option' cannot occur without the corresponding type which it is wrapping
- this is not the case here, in this language, Option is a function of type (Type -> Type)

It is now time for the quintessential datatype in functional programming, List (which happens to be an inductive type):
```haskell
data List (A : Type) : Type where
  nil  : List A
  _::_ : A -> List A -> List A

hahalol : List Nat
hahalol := 3 :: (2 :: (1 :: (0 :: nil)))
```

in hypothetical rust syntax:
```rust
enum List<A> {
  nil,
  cons(A, List<A>),
}

let hahalol: List<Nat> = cons(3, cons(2, cons(1, cons(0, nil))));
```

- Now onto indices
- indices may seem like parameters, but they are (very) different

consider
```haskell
-- Vect is a function of type (Type -> Nat -> Type)
-- parameter -v         v---- index
data Vect (A : Type) : Nat -> Type where
  nil  : Vect A 0
  _::_ : A -> {n : Nat} -> Vect A n -> Vect A (suc n)

empty : Vect Nat 0
empty := nil

-- this does not typecheck
alsoEmpty : Vect Nat 256
alsoEmpty := nil -- <- nil is of type Vect Nat 0, not Vect Nat 256
```

- this new type 'Vect' is almost the same as 'List', with the difference being that the length is now a part of the type

- so what is the difference between parameters and indices
- notics how for each different type A, (Option A) is a separate inductive type. You can almost find and replace A with actual types and get back a valid inductive definition
- the same is not true for indices, though (Vect A) is a separate inductive family for each different A, (Vect A zero) is not a separate inductive type, neither is (Vect A (suc zero))