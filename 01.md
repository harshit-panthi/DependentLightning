# Dependent Types

## syntax for rest of the pages
- mostly Haskell like (though not identical)
- n : Nat means that 'n' is a value of type 'Nat'
- f : A -> B -> C means that 'f' is a function that takes a value of type 'A' and a value of type 'B' and returns a value of type 'C'
- n := zero means that zero is assigned to the value n
- function application requires no brackets, so 'f x' means calling the function f with the value x (basically f(x) in C-like languages)
- the usage of '=' is somewhat complicated, it is *not* the assignment operator, nor '\==' (it is a type constructor, like Option, Result, Vec, etc. in Rust)
- What exactly is a type constructor will be discussed later

example:
```haskell
hi : Nat
hi := zero

factorial : Nat -> Nat
factorial 0 := 1
factorial 1 := 1
factorial (suc (suc n)) := (f n) + (f (suc n))
```

though the code block says the language is haskell, its not true. I only wrote haskell so that it syntax highlights

## notes
- for the rest of the presentation, it will be assumed that zero is a natural number
- the language I am talking about will be a pure functional language (which means *no* side effects and *no* mutability)
- the language will be declarative, so no loops, only recursion, and no statements, only expressions
- in fact, it will be even more restrictive than that, the language will only allow terminating programs, which means it wont even be turing complete (the why will be discussed later)
- also, in this language, types are first class objects
---
# With that out of the way, lets start