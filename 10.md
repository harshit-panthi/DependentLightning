# Wait, theres more

consider
```haskell
f : Nat -> Type
f zero := Nat
f (suc n) := Nat -> (f n)

adder' : Nat -> (n : Nat) -> (f n)
adder' a zero := a
adder' a (suc n) := b => (adder' (a + b) n)

adder : (n : Nat) -> (f n)
adder n := adder' zero n
```

- adder is a variadic function which adds n values!!!
- keep in mind the fact that I never explicitly had to say that this language supported variadic functions
- there is *much* more cool stuff made possible by dependent type which would require further detours to explain the workings of
- you can make a datatype which contains two functions, one the client and one the server, and require that those two be compatible
- in fact, you can make a DSL that describes the protocol and have the compiler generate code for you (without ever writing macros for the code generation part)
- dependent types make the programming of compilers and evaluators much easier than it is in languages without them
- Inductive types are very good at modelling state machines and dependent types are pretty good at maintaining invariants of transitions.
- Dependent type make redundant many design patterns common in rust (such as 'parse don't verify', etc.) by offering much better alternatives.
- you can write your programs in easier-to-work-with datastructures, and then transport those programs to a much more efficient datastructure that isn't the nicest to work with just by proving that those two datastructures are isomorphic (essentially equal) to each other
- with something called *Higher Inductive Types* along with an additional rule called the *Univalence Axiom*, you can express true quotient types
- and much more